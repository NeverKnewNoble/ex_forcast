---
alwaysApply: true
---
Architectural Patterns
⦁	Separation of Concerns: Extract business logic into composables and services. Avoid 1800+ line Vue files mixing business logic with UI.
⦁	Single Responsibility Principle: Break down large components into focused, single-purpose modules to ensure maintainability and SOLID compliance.
Data Management Patterns
⦁	Centralized State Management: Use domain-specific Pinia stores to manage state like fnbData, banquetData etc.
⦁	Data Normalization: Use lookup tables and normalized structures to prevent duplication and inconsistencies.
⦁	Command Pattern for State Changes: Use action-based state updates to track and allow undo/redo functionality.
Reactive Programming Concepts
⦁	Computed Properties Strategy: Replace manual calculations with computed properties for better performance and reactivity.
Observer Pattern Implementation
⦁	Event Communication: Use an event bus or observer pattern for decoupled cross-component communication.
Immediate Priority Recommendations
⦁	Use Models for Data Transmission: Structure your API and UI communication with JS models or interfaces.
⦁	Implement Domain Stores: Centralize state management by domain.
⦁	Add Type Safety: Integrate comprehensive validation in absence of TypeScript.
⦁	Extract Services: Separate API logic into service layers.
⦁	Implement Error Handling: Introduce global error handling and user feedback mechanisms.
Known Issues and Fixes
⦁	Performance: Avoid unnecessary re-renders and computations by leveraging computed properties.
⦁	Error Handling: Avoid generic exception handling.
⦁	State Management: Avoid over-reliance on localStorage. Use Pinia stores instead.
⦁	Security: Remove console logs from production to prevent data exposure.